;; MAGUS Milestone 4: Ethical Scenario Runner
;; Loads scenarios from YAML and executes them through the MAGUS pipeline
;; Implements ES2: scenario loader and ES4: logging pipeline

;; Import dependencies
!(load scenarios.metta)
!(load ../Milestone_3/core/metagoals.metta)
!(load ../Milestone_3/core/antigoals.metta)
!(load ../Milestone_3/core/scoring-v2.metta)
!(load ../Milestone_3/core/planner-bt.metta)

;; =============================================================================
;; Ethical Logging Pipeline
;; =============================================================================

;; Dedicated space for ethical decision logs
!(bind! &ethical-log (new-space))

;; Log entry for ethical decision step
(: EthicalLogEntry Type)
(: log-entry (->
    Symbol          ;; scenario-id
    Number          ;; timestep
    Number          ;; decision-score
    (List (Tuple Symbol Number))  ;; metagoal-breakdown
    (List (Tuple Symbol Number))  ;; antigoal-breakdown
    $a              ;; plan (action or candidate)
    Symbol          ;; status (success/failure/pending)
    Number          ;; latency-ms
    String          ;; notes
    EthicalLogEntry))

;; Record an ethical decision step
(: trace-ethical-step (->
    Symbol          ;; scenario-id
    Number          ;; timestep
    Number          ;; decision-score
    (List (Tuple Symbol Number))  ;; metagoal-breakdown
    (List (Tuple Symbol Number))  ;; antigoal-breakdown
    $a              ;; plan
    Symbol          ;; status
    Number          ;; latency-ms
    String          ;; notes
    ()))
(= (trace-ethical-step $scenario-id $timestep $score $metagoals $antigoals $plan $status $latency $notes)
   (add-atom &ethical-log
     (log-entry $scenario-id $timestep $score $metagoals $antigoals $plan $status $latency $notes)))

;; Get all log entries for a scenario
(: get-scenario-log (-> Symbol (List EthicalLogEntry)))
(= (get-scenario-log $scenario-id)
   (match &ethical-log
     (log-entry $scenario-id $ts $score $mg $ag $plan $status $latency $notes)
     (log-entry $scenario-id $ts $score $mg $ag $plan $status $latency $notes)))

;; Helper for removing a single log entry (named function, not lambda)
(: remove-log-entry (-> EthicalLogEntry ()))
(= (remove-log-entry $entry)
   (remove-atom &ethical-log $entry))

;; Clear log for a scenario
(: clear-scenario-log (-> Symbol ()))
(= (clear-scenario-log $scenario-id)
   (let $entries (get-scenario-log $scenario-id)
     (clear-entries $entries)))

;; Clear entries using fold (avoid mutation in map-atom lambda)
(: clear-entries (-> (List EthicalLogEntry) ()))
(= (clear-entries Nil) ())
(= (clear-entries (Cons $entry $tail))
   (let (_ (remove-log-entry $entry))
     (clear-entries $tail)))

;; Clear all logs
(: clear-all-logs (-> ()))
(= (clear-all-logs)
   (let $all-entries (match &ethical-log $entry $entry)
     (clear-entries $all-entries)))

;; =============================================================================
;; Helper Functions for Scenario Execution
;; =============================================================================

;; Generate candidates from goals and scoring context
(: generate-candidates (-> (List Goal) ScoringContext (List Candidate)))
(= (generate-candidates Nil $context) Nil)
(= (generate-candidates (Cons $goal $tail) $context)
   (Cons (goal-candidate $goal)
         (generate-candidates $tail $context)))

;; Apply anti-goals to filter candidates (list variant)
(: apply-anti-goals (-> (List AntiGoal) (List Candidate) (List Candidate)))
(= (apply-anti-goals $antigoals $candidates)
   ;; Filter out candidates that violate hard constraints
   (filter-safe-candidates $antigoals $candidates))

(: filter-safe-candidates (-> (List AntiGoal) (List Candidate) (List Candidate)))
(= (filter-safe-candidates $antigoals Nil) Nil)
(= (filter-safe-candidates $antigoals (Cons $cand $tail))
   (if (is-safe-candidate $antigoals $cand)
       (Cons $cand (filter-safe-candidates $antigoals $tail))
       (filter-safe-candidates $antigoals $tail)))

(: is-safe-candidate (-> (List AntiGoal) Candidate Bool))
(= (is-safe-candidate Nil $cand) True)
(= (is-safe-candidate (Cons (anti-goal $name Hard $fn) $tail) $cand)
   ;; Hard constraints must pass (penalty != 0 means veto)
   (let $penalty ($fn (context Nil 0) $cand)
     (if (== $penalty 0)
         False  ;; Vetoed
         (is-safe-candidate $tail $cand))))
(= (is-safe-candidate (Cons $_ $tail) $cand)
   (is-safe-candidate $tail $cand))

;; Score all candidates with M3's score-decision-v2 pipeline
(: score-all-v2 (-> (List Candidate)
                    (List Goal)
                    (List AntiGoal)
                    (List Metagoal)
                    ScoringContext
                    (List (Tuple Candidate DecisionScore))))
(= (score-all-v2 Nil $goals $antigoals $metagoals $context) Nil)
(= (score-all-v2 (Cons $cand $tail) $goals $antigoals $metagoals $context)
   (let* (;; Define considerations and discouragements for this scenario
          ($considerations (scenario-considerations $cand $goals))
          ($discouragements (scenario-discouragements $cand))
          ;; Use M3's score-decision-v2
          ($score (score-decision-v2 $cand $considerations $discouragements
                                     $metagoals $antigoals $context)))
     (Cons (Tuple $cand $score)
           (score-all-v2 $tail $goals $antigoals $metagoals $context))))

;; Define considerations for ethical scenarios
(: scenario-considerations (-> Candidate (List Goal) (List Consideration)))
(= (scenario-considerations $cand $goals)
   (Cons (consideration goal-alignment
                       (lambda $ctx (goal-alignment-score $cand $goals)))
   (Cons (consideration ethical-value
                       (lambda $ctx (ethical-value-score $cand)))
   Nil)))

;; Score how well candidate aligns with goals
(: goal-alignment-score (-> Candidate (List Goal) Number))
(= (goal-alignment-score (goal-candidate $goal) $goals)
   (* 50 (goal-priority $goal)))  ;; Base score from goal priority
(= (goal-alignment-score (action-candidate $action) $goals)
   25)  ;; Default for actions

;; Score ethical value of candidate
(: ethical-value-score (-> Candidate Number))
(= (ethical-value-score (goal-candidate (goal $name $p $w)))
   (* 30 $w))  ;; Base score from goal weight
(= (ethical-value-score (action-candidate $action))
   20)  ;; Default for actions

;; Define discouragements for ethical scenarios
(: scenario-discouragements (-> Candidate (List Discouragement)))
(= (scenario-discouragements $cand)
   (Cons (discouragement ethical-risk
                        (lambda $ctx (ethical-risk-score $cand)))
   Nil))

;; Score ethical risk of candidate
(: ethical-risk-score (-> Candidate Number))
(= (ethical-risk-score (goal-candidate $goal))
   5)  ;; Low baseline risk for goals
(= (ethical-risk-score (action-candidate $action))
   10)  ;; Slightly higher risk for actions

;; Select best candidate from scored list (with DecisionScore)
(: select-best-candidate (-> (List (Tuple Candidate DecisionScore)) (Tuple Candidate DecisionScore)))
(= (select-best-candidate Nil)
   (Tuple (goal-candidate (goal unknown 0.0 0.0))
          (decision-score 0 0 0 0)))
(= (select-best-candidate (Cons (Tuple $cand $score) Nil))
   (Tuple $cand $score))
(= (select-best-candidate (Cons (Tuple $c1 $s1) (Cons (Tuple $c2 $s2) $tail)))
   (if (> (extract-final-score $s1) (extract-final-score $s2))
       (select-best-candidate (Cons (Tuple $c1 $s1) $tail))
       (select-best-candidate (Cons (Tuple $c2 $s2) $tail))))

;; Extract final score from DecisionScore
(: extract-final-score (-> DecisionScore Number))
(= (extract-final-score (decision-score $base $meta $anti $final))
   $final)

;; =============================================================================
;; Scenario Execution
;; =============================================================================

;; Execute a scenario and return the result
(: run-scenario (-> Symbol ScenarioContext (List Goal) (List AntiGoal) (List Metagoal) $result))
(= (run-scenario $scenario-id $scenario-ctx $goals $antigoals $metagoals)
   (let* ((start-time (get-timestamp-ms))
          ;; Create ScoringContext from scenario context
          ($scoring-ctx (create-scoring-context-from-scenario $scenario-ctx $goals))
          ;; Apply anti-goal constraints
          ($candidates (generate-candidates $goals $scoring-ctx))
          ($vetted-candidates (apply-anti-goals $antigoals $candidates))
          ;; Score remaining candidates with M3 pipeline
          ($scored (score-all-v2 $vetted-candidates $goals $antigoals $metagoals $scoring-ctx))
          ;; Select best action
          ((Tuple $best $best-score) (select-best-candidate $scored))
          ;; Extract DecisionScore components
          ((decision-score $base $meta-adj $anti-penalty $final) $best-score)
          ;; Create breakdown tuples
          ($metagoal-breakdown (list (Tuple metagoal-adjustment $meta-adj)))
          ($antigoal-breakdown (list (Tuple antigoal-penalty $anti-penalty)))
          (end-time (get-timestamp-ms))
          ($latency (- end-time start-time)))
     ;; Log the decision
     (trace-ethical-step
       $scenario-id
       1
       $final
       $metagoal-breakdown
       $antigoal-breakdown
       $best
       pending
       $latency
       "Scenario execution with M3 scoring completed")
     ;; Return result
     (tuple $best $final $metagoal-breakdown $antigoal-breakdown)))

;; Create ScoringContext from ScenarioContext
(: create-scoring-context-from-scenario (-> ScenarioContext (List Goal) ScoringContext))
(= (create-scoring-context-from-scenario $scenario-ctx $goals)
   (let* (;; Extract danger level to create modulators
          ($danger (scenario-context-danger-level $scenario-ctx))
          ($modulators (danger-to-modulators $danger)))
     ;; Create ScoringContext with goals, modulators, and timestamp
     (scoring-context $goals $modulators (get-timestamp-ms))))

;; Convert danger level to modulators
(: danger-to-modulators (-> Symbol (List Modulator)))
(= (danger-to-modulators low)
   (Cons (modulator arousal 0.3)
   (Cons (modulator focus 0.4)
   Nil)))
(= (danger-to-modulators medium)
   (Cons (modulator arousal 0.6)
   (Cons (modulator focus 0.7)
   Nil)))
(= (danger-to-modulators high)
   (Cons (modulator arousal 0.9)
   (Cons (modulator focus 1.0)
   Nil)))
(= (danger-to-modulators $_)  ;; Default
   (Cons (modulator arousal 0.5)
   (Cons (modulator focus 0.5)
   Nil)))


;; =============================================================================
;; Anti-goal Contribution Extraction
;; =============================================================================

;; Extract anti-goal contributions by comparing candidates before/after veto
(: extract-antigoal-contributions (-> (List AntiGoal) (List Candidate) (List Candidate) (List (Tuple Symbol Number))))
(= (extract-antigoal-contributions $antigoals $before $after)
   (let $vetoed-count (- (length $before) (length $after))
     (if (> $vetoed-count 0)
         (list (Tuple hard-veto $vetoed-count))
         (extract-soft-penalties $antigoals $after))))

;; Extract soft anti-goal penalties
(: extract-soft-penalties (-> (List AntiGoal) (List Candidate) (List (Tuple Symbol Number))))
(= (extract-soft-penalties Nil $_) Nil)
(= (extract-soft-penalties (Cons $ag $tail) $candidates)
   (let $penalty (calculate-soft-penalty $ag $candidates)
     (if (> $penalty 0.0)
         (Cons (Tuple (antigoal-name $ag) $penalty)
               (extract-soft-penalties $tail $candidates))
         (extract-soft-penalties $tail $candidates))))

;; Calculate soft penalty for an anti-goal across candidates
(: calculate-soft-penalty (-> AntiGoal (List Candidate) Number))
(= (calculate-soft-penalty $ag Nil) 0.0)
(= (calculate-soft-penalty $ag (Cons $cand $tail))
   (+ (get-candidate-penalty $ag $cand)
      (calculate-soft-penalty $ag $tail)))

;; Get penalty for a specific candidate (placeholder - should use scoring-v2 logic)
(: get-candidate-penalty (-> AntiGoal Candidate Number))
(= (get-candidate-penalty $ag $cand) 0.0)  ;; TODO: Extract from scoring-v2

;; =============================================================================
;; Timestamp Utilities
;; =============================================================================

;; Get current timestamp in milliseconds (placeholder)
(: get-timestamp-ms (-> Number))
(= (get-timestamp-ms) 0.0)  ;; TODO: Implement actual timestamp


;; =============================================================================
;; Scenario Assertion (ES5)
;; =============================================================================

;; Assert scenario passes all success metrics
(: assert-scenario-pass (-> Symbol Bool))
(= (assert-scenario-pass $scenario-id)
   (let* (($scenario (get-scenario $scenario-id))
          ($metrics (scenario-success-metrics $scenario))
          ($log (get-scenario-log $scenario-id))
          ($results (evaluate-metrics $metrics $log)))
     (all-metrics-pass $results)))

;; Evaluate all metrics against log
(: evaluate-metrics (-> (List SuccessMetric) (List EthicalLogEntry) (List Bool)))
(= (evaluate-metrics Nil $_) Nil)
(= (evaluate-metrics (Cons $metric $tail) $log)
   (Cons (eval-metric-against-log $metric $log)
         (evaluate-metrics $tail $log)))

;; Evaluate single metric against log
(: eval-metric-against-log (-> SuccessMetric (List EthicalLogEntry) Bool))
(= (eval-metric-against-log (metric-boolean no-hard-violations $expected) $log)
   (no-hard-violations-in-log $log))

(= (eval-metric-against-log (metric-comparison final-score >= $threshold) $log)
   (let $final-entry (last $log)
     (>= (log-entry-score $final-entry) $threshold)))

(= (eval-metric-against-log $_ $_) True)  ;; Fallback for unimplemented metrics

;; Check for hard violations in log
(: no-hard-violations-in-log (-> (List EthicalLogEntry) Bool))
(= (no-hard-violations-in-log Nil) True)
(= (no-hard-violations-in-log (Cons $entry $tail))
   (and (no-hard-veto-in-entry $entry)
        (no-hard-violations-in-log $tail)))

;; Check if entry has hard veto
(: no-hard-veto-in-entry (-> EthicalLogEntry Bool))
(= (no-hard-veto-in-entry (log-entry $_ $_ $_ $_ $antigoals $_ $_ $_ $_))
   (not (contains-hard-veto $antigoals)))

;; Check if anti-goal breakdown contains hard veto
(: contains-hard-veto (-> (List (Tuple Symbol Number)) Bool))
(= (contains-hard-veto Nil) False)
(= (contains-hard-veto (Cons (Tuple hard-veto $_) $_)) True)
(= (contains-hard-veto (Cons $_ $tail)) (contains-hard-veto $tail))

;; Check if all metrics passed
(: all-metrics-pass (-> (List Bool) Bool))
(= (all-metrics-pass Nil) True)
(= (all-metrics-pass (Cons False $_)) False)
(= (all-metrics-pass (Cons True $tail)) (all-metrics-pass $tail))

;; Get log entry score
(: log-entry-score (-> EthicalLogEntry Number))
(= (log-entry-score (log-entry $_ $_ $score $_ $_ $_ $_ $_ $_)) $score)

;; Get last element of list
(: last (-> (List $a) $a))
(= (last (Cons $x Nil)) $x)
(= (last (Cons $_ $tail)) (last $tail))

;; =============================================================================
;; Remediation Hints
;; =============================================================================

;; Get remediation hint for failed scenario
(: get-remediation-hint (-> Symbol String))
(= (get-remediation-hint $scenario-id)
   (let $scenario (get-scenario $scenario-id)
     (scenario-remediation-hint $scenario)))

;; =============================================================================
;; Export Logging to JSON (ES4)
;; =============================================================================

;; Export all logs to JSON file (via Python bridge)
(: export-ethical-log (-> String ()))
(= (export-ethical-log $path)
   ;; TODO: Implement Python bridge for JSON export
   (println "Exporting ethical log to " $path))

;; =============================================================================
;; Statistics
;; =============================================================================

;; Get total log entries
(: total-log-entries (-> Number))
(= (total-log-entries)
   (length (match &ethical-log $entry $entry)))

;; Get log entries by status
(: log-entries-by-status (-> Symbol Number))
(= (log-entries-by-status $status)
   (length (match &ethical-log
             (log-entry $_ $_ $_ $_ $_ $_ $status $_ $_)
             True)))

;; =============================================================================
;; Export Functions
;; =============================================================================

(: scenario-runner-exports (-> (List Symbol)))
(= (scenario-runner-exports)
   (list
     run-scenario
     trace-ethical-step
     assert-scenario-pass
     get-scenario-log
     get-remediation-hint
     export-ethical-log
     clear-scenario-log
     clear-all-logs))

!(println "Ethical Scenario Runner Loaded")
!(println "Functions: run-scenario, trace-ethical-step, assert-scenario-pass")
!(println "Logging: &ethical-log space, export-ethical-log")
